// controllers/mcq.controller.js
const openai = require('../config/openaiClient');
const { v4: uuidv4 } = require('uuid');
const { supabase } = require('../config/supabaseClient');

const PROMPT_TEMPLATE = `ðŸš¨ OUTPUT RULES:
... [same as your mcq.worker.js PROMPT_TEMPLATE above] ...
`;

const validateMCQ = (mcq) => {
  if (!mcq?.stem || typeof mcq.stem !== 'string') return false;
  if (!mcq?.options || typeof mcq.options !== 'object') return false;
  const required = ['A', 'B', 'C', 'D', 'E'];
  const allPresent = required.every((opt) => typeof mcq.options[opt] === 'string' && mcq.options[opt].trim() !== '');
  return allPresent && required.includes(mcq.correct_answer);
};

const insertMCQ = async (raw, mcq, level) => {
  const id = uuidv4();
  const { error } = await supabase.from('mcqs').insert({
    id,
    exam_id: raw.exam_id,
    subject_id: raw.subject_id,
    stem: mcq.stem,
    option_a: mcq.options?.A,
    option_b: mcq.options?.B,
    option_c: mcq.options?.C,
    option_d: mcq.options?.D,
    option_e: mcq.options?.E,
    correct_answer: mcq.correct_answer,
    explanation: mcq.explanation || '',
    learning_gap: mcq.learning_gap || '',
    level,
    mcq_json: mcq,
  });
  if (error) throw error;
  return id;
};

exports.generateFromRaw = async (req, res) => {
  const mcqs = req.body?.mcqs || [];
  if (!Array.isArray(mcqs) || mcqs.length === 0) {
    return res.status(400).json({ error: 'Invalid or empty MCQ array' });
  }

  const results = [];

  for (const raw of mcqs) {
    const prompt = `${PROMPT_TEMPLATE}

Here is the MCQ:

Question: ${raw.question}
Options:
${raw.options?.join('\n')}
Correct Answer: ${raw.correct_answer}`;

    try {
      const chatResponse = await openai.chat.completions.create({
        model: 'gpt-4-0613',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.7,
      });

      const parsed = JSON.parse(chatResponse.choices[0].message.content);

      if (!validateMCQ(parsed.primary_mcq)) throw new Error('Primary MCQ validation failed');
      const primaryId = await insertMCQ(raw, parsed.primary_mcq, 0);

      const recursiveIds = [];
      if (!Array.isArray(parsed.recursive_levels)) throw new Error('Recursive levels missing');

      for (let i = 0; i < parsed.recursive_levels.length; i++) {
        const levelMCQ = parsed.recursive_levels[i];
        if (!validateMCQ(levelMCQ)) throw new Error(`Recursive level ${i + 1} validation failed`);
        const id = await insertMCQ(raw, levelMCQ, i + 1);
        recursiveIds.push(id);
      }

      await supabase.from('mcq_graphs').insert({
        exam_id: raw.exam_id,
        subject_id: raw.subject_id,
        raw_mcq_id: null,
        graph: {
          primary_mcq: primaryId,
          recursive_levels: recursiveIds,
        },
        generated: true,
      });

      results.push({ status: 'success', question: raw.question, primary_id: primaryId });
    } catch (err) {
      results.push({ status: 'error', question: raw.question, error: err.message });
    }
  }

  res.json({ results });
};

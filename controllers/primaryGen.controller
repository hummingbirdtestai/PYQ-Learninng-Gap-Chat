// controllers/primaryGen.controller.js
const { supabase } = require('../config/supabaseClient');
const openai = require('../config/openaiClient');

// === Tunables (GEN_* so they don't clash with other controllers) ===
const GEN_MODEL = process.env.GEN_MODEL || 'gpt-5-mini';
const GEN_DEFAULT_LIMIT = parseInt(process.env.GEN_LIMIT || '40', 10);
const GEN_MAX_LIMIT = 100;
const GEN_CONCURRENCY = parseInt(process.env.GEN_CONCURRENCY || '3', 10);
const GEN_LOCK_TTL_MIN = parseInt(process.env.GEN_LOCK_TTL_MIN || '20', 10);
const GEN_MAX_TOKENS = parseInt(process.env.GEN_MAX_TOKENS || '1800', 10);

// === Your prompt (renamed to avoid collisions) ===
const PRIMARY_PROMPT_TEMPLATE = `üö® OUTPUT RULES: Your entire output must be a single valid JSON object.
- DO NOT include \`\`\`json or any markdown syntax.
- DO NOT add explanations, comments, or headings.
- Your output MUST start with { and end with }.
- It must be directly parsable by JSON.parse().

üî¨ You are an expert medical educator and exam learning strategist.
üéØ Your role is to act as a *Learning Gap Diagnostician* for MBBS/MD aspirants preparing for FMGE, NEETPG, INICET, or USMLE.
üß† OBJECTIVE:
You will be given a *Previous Year Question (PYQ)* MCQ that a student got wrong. Your task is to:

1. Reframe the MCQ as a clinical vignette with *exactly 5 full sentences*, USMLE-style.  
   - The MCQ stem must resemble Amboss/NBME/USMLE-level difficulty.  
   - Bold all *high-yield keywords* using <strong>...</strong>.  
   - If an image is mentioned or implied but not provided, imagine a *relevant clinical/anatomical image* and incorporate its findings logically into the stem.

2. Provide 4 answer options (A‚ÄìD), with one correct answer clearly marked.

3. Identify the *key learning gap* if the MCQ was answered wrong.
   - The learning gap statement must be *one sentence*, and include <strong>bolded keywords</strong> for the missed concept.

4. Provide 10 *high-quality, laser-sharp, buzzword-style facts* related to the concept of the current MCQ:
   - Each fact must be *8 to 12 words long*, maximum of one sentence.
   - Start with a relevant *emoji*.
   - Bold key terms using <strong>...</strong>.
   - Format as flat strings in a "buzzwords": [] array.
   - Style should match Amboss/NBME/USMLE exam revision quality ‚Äî *concise, specific, exam-sure*.

5. Output a single JSON object:
   - "primary_mcq" ‚Üí for the initial MCQ
   - "learning_gap" ‚Üí for the missed concept
   - "buzzwords" ‚Üí for revision

üí° Notes:
All "stem" and "learning_gap" values must contain 2 or more <strong>...</strong> terms.
If the original MCQ implies an image (e.g., anatomy, CT scan, fundus, histo slide), describe it logically in sentence 5 of the MCQ stem.
All "buzzwords" must be 10 high-yield, bolded HTML-formatted one-liners, each starting with an emoji.
`;

// ---- helpers (all prefixed to avoid clashes) ----
const genSleep = (ms) => new Promise(r => setTimeout(r, ms));

async function genAsyncPool(limit, items, iter) {
  const ret = []; const exec = [];
  for (const it of items) {
    const p = Promise.resolve().then(() => iter(it));
    ret.push(p);
    const e = p.then(() => exec.splice(exec.indexOf(e), 1));
    exec.push(e);
    if (exec.length >= limit) await Promise.race(exec);
  }
  return Promise.allSettled(ret);
}

function genCleanAndParseJSON(raw) {
  let t = (raw || '').trim()
    .replace(/^```json\s*/i, '')
    .replace(/^```\s*/i, '')
    .replace(/```$/, '')
    .trim();
  const first = t.indexOf('{'); const last = t.lastIndexOf('}');
  if (first === -1 || last === -1 || last < first) throw new Error('No JSON object found');
  t = t.slice(first, last + 1);
  return JSON.parse(t);
}

function genBuildPrompt(row) {
  const mcqText = typeof row.mcq === 'string'
    ? row.mcq
    : (row.mcq?.stem || row.mcq?.question || row.mcq?.text || JSON.stringify(row.mcq));
  return `${PRIMARY_PROMPT_TEMPLATE}\n\nMCQ: ${mcqText}\nCorrect Answer: ${row.correct_answer || ''}`;
}

function genIsRetryable(e) {
  const s = String(e?.message || e);
  return /timeout|ETIMEDOUT|429|rate limit|temporar|unavailable|ECONNRESET/i.test(s);
}

async function genCallOpenAIWithRetry(messages, attempt = 1) {
  try {
    const resp = await openai.chat.completions.create({
      model: GEN_MODEL,
      temperature: 0.6,
      max_tokens: GEN_MAX_TOKENS,
      messages
    });
    return resp.choices?.[0]?.message?.content || '';
  } catch (e) {
    if (genIsRetryable(e) && attempt <= 3) {
      await genSleep(400 * attempt);
      return genCallOpenAIWithRetry(messages, attempt + 1);
    }
    throw e;
  }
}

// ---- locking ----
async function genClaimRows(limit, workerId) {
  const cutoff = new Date(Date.now() - GEN_LOCK_TTL_MIN * 60 * 1000).toISOString();

  // 1) candidates
  const { data: candidates, error: e1 } = await supabase
    .from('mcq_bank')
    .select('id')
    .is('primary_mcq', null)
    .or(`primary_lock.is.null,primary_locked_at.lt.${cutoff}`)
    .order('id', { ascending: true })
    .limit(limit * 3);
  if (e1) throw e1;
  if (!candidates?.length) return [];

  const ids = candidates.map(r => r.id);

  // 2) lock & fetch rows
  const { data: locked, error: e2 } = await supabase
    .from('mcq_bank')
    .update({ primary_lock: workerId, primary_locked_at: new Date().toISOString() })
    .in('id', ids)
    .is('primary_mcq', null)
    .is('primary_lock', null)
    .select('id, mcq, correct_answer');
  if (e2) throw e2;

  return (locked || []).slice(0, limit);
}

async function genClearLocks(ids) {
  if (!ids.length) return;
  await supabase
    .from('mcq_bank')
    .update({ primary_lock: null, primary_locked_at: null })
    .in('id', ids);
}

// ---- per-row processor ----
async function genProcessRow(row) {
  const prompt = genBuildPrompt(row);
  const raw = await genCallOpenAIWithRetry([{ role: 'user', content: prompt }]);
  const parsed = genCleanAndParseJSON(raw);

  if (!parsed.primary_mcq || !parsed.learning_gap || !Array.isArray(parsed.buzzwords)) {
    throw new Error('Missing required fields in JSON');
  }

  const { error: upErr } = await supabase
    .from('mcq_bank')
    .update({ primary_mcq: parsed, primary_lock: null, primary_locked_at: null })
    .eq('id', row.id);
  if (upErr) throw upErr;

  return { id: row.id, ok: true };
}

// ---- main API ----
exports.generatePrimaryMCQs = async (req, res) => {
  const limit = Math.min(parseInt(req.query.limit || GEN_DEFAULT_LIMIT, 10), GEN_MAX_LIMIT);
  const concurrency = Math.max(1, parseInt(req.query.concurrency || GEN_CONCURRENCY, 10));
  const workerId = req.headers['x-worker-id'] || `w-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;

  try {
    const claimed = await genClaimRows(limit, workerId);
    if (!claimed.length) {
      return res.status(200).json({ message: 'No pending rows', claimed: 0, updated: 0, failed: 0, model: GEN_MODEL });
    }

    const results = await genAsyncPool(concurrency, claimed, r => genProcessRow(r));
    const updated = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.length - updated;

    // clear locks for failed ones
    const stillLockedIds = claimed
      .filter((_, i) => results[i].status !== 'fulfilled')
      .map(r => r.id);
    await genClearLocks(stillLockedIds);

    return res.status(200).json({
      message: 'OK',
      model: GEN_MODEL,
      claimed: claimed.length,
      updated,
      failed,
      concurrency,
    });
  } catch (err) {
    console.error('‚ùå generatePrimaryMCQs error:', err.message || err);
    return res.status(500).json({ error: 'Internal Server Error', details: err.message });
  }
};
